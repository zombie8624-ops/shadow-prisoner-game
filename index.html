<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 优化视口设置，禁止缩放，适配刘海屏 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- iOS/Android Web App 全屏设置 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <title>Shadow Prisoner: Infinite Run</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* 全局禁止选中和长按菜单，提升手感 */
        * {
            -webkit-touch-callout: none; /* 禁止长按弹出菜单 */
            -webkit-user-select: none;   /* 禁止选中文字 */
            user-select: none;
            -webkit-tap-highlight-color: transparent; /* 禁止点击高亮 */
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0d0d15; 
            color: #fff; 
            font-family: 'Press Start 2P', cursive; 
            touch-action: none; /* 关键：禁止浏览器处理触摸手势 */
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; image-rendering: crisp-edges; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .hud { padding: 20px; text-shadow: 2px 2px 0 #000; display: flex; justify-content: space-between; align-items: flex-start; z-index: 10; }
        .hud-left { display: flex; flex-direction: column; gap: 5px; }
        
        .hud-row { display: flex; align-items: flex-start; }
        
        .hud-right { text-align: right; display: flex; flex-direction: column; align-items: flex-end; }
        
        #health-bar-container { width: 300px; height: 30px; background: #333; border: 4px solid #555; margin-bottom: 5px; transform: skewX(-15deg); box-shadow: 2px 2px 5px rgba(0,0,0,0.5); position: relative; overflow: hidden; }
        #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff4444, #ff0000); box-shadow: 0 0 10px #ff0000; transition: width 0.1s; }
        
        #energy-bar-container { width: 250px; height: 15px; background: #222; border: 2px solid #444; transform: skewX(-15deg); position: relative; overflow: hidden; }
        #energy-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #aa00ff, #5500aa); box-shadow: 0 0 10px #aa00ff; transition: width 0.1s; }
        #energy-text { position: absolute; top: -20px; left: 0; font-size: 10px; color: #d0f; text-shadow: 0 0 5px #d0f; display: none; width: 100%; text-align: center; }

        #cells-count { color: #00ffff; font-size: 16px; margin-top: 10px; letter-spacing: 1px; }
        #status-panel { margin-top: 15px; font-size: 12px; color: #00ff00; line-height: 1.5; }
        #dist-display { font-size: 20px; color: #fff; margin-bottom: 5px; }
        #danger-display { font-size: 16px; color: #ff4444; margin-bottom: 20px; }
        
        #skill-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            z-index: 20; 
            pointer-events: auto; 
            transition: opacity 0.3s; 
            margin-left: 15px;
            transform: skewX(-15deg); 
            margin-top: -5px;
        }
        
        #skill-icon { width: 60px; height: 60px; border: 4px solid #00ffff; background: rgba(0, 255, 255, 0.2); display: flex; justify-content: center; align-items: center; font-size: 30px; color: #00ffff; border-radius: 10px; position: relative; box-shadow: 0 0 15px #00ffff; transition: all 0.2s; text-shadow: 0 0 5px #fff; }
        #skill-icon.cooldown { border-color: #555; background: rgba(0,0,0,0.5); color: #555; box-shadow: none; text-shadow: none; }
        #skill-timer { position: absolute; font-size: 20px; color: #fff; font-weight: bold; }
        #skill-label { margin-top: 5px; font-size: 10px; color: #ccc; text-shadow: 1px 1px 0 #000; }
        
        .desktop-hint { color: #888; position: absolute; bottom: 10px; left: 10px; font-size: 10px; line-height: 1.5; z-index: 6; }
        
        /* Start Screen 保持原样 */
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; pointer-events: auto; overflow: hidden; }
        
        /* ==========================================================================
           CYBERPUNK GAME OVER STYLES (NEW)
           ========================================================================== */
        #game-over-screen { 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            z-index: 100; pointer-events: auto; overflow: hidden; 
            
            /* 深色赛博背景 + 网格叠加 */
            background-color: #050510;
            background-image: 
                linear-gradient(rgba(0, 20, 20, 0.8), rgba(0, 10, 10, 0.9)),
                repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(0, 255, 255, 0.05) 1px, rgba(0, 255, 255, 0.05) 2px);
            backdrop-filter: blur(5px);
        }

        /* 扫描线动画覆盖层 */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            animation: scrollScanlines 10s linear infinite;
            pointer-events: none;
            z-index: 1;
            opacity: 0.6;
        }

        /* 赛博朋克风格的主容器 */
        .cyber-box {
            position: relative;
            padding: 40px 60px;
            background: rgba(10, 15, 20, 0.85);
            border: 2px solid #00f3ff;
            /* 霓虹发光效果 */
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3), inset 0 0 30px rgba(0, 243, 255, 0.1);
            transform: skewX(-5deg);
            text-align: center;
            z-index: 10;
            /* 科技感的多边形裁剪 */
            clip-path: polygon(
                10% 0, 100% 0, 
                100% 85%, 90% 100%, 
                0 100%, 0 15%
            );
        }

        /* 装饰用的角落线条 */
        .cyber-box::before {
            content: ''; position: absolute; top: 5px; left: 5px; width: 20px; height: 20px;
            border-top: 3px solid #ff00ff; border-left: 3px solid #ff00ff;
        }
        .cyber-box::after {
            content: ''; position: absolute; bottom: 5px; right: 5px; width: 20px; height: 20px;
            border-bottom: 3px solid #ff00ff; border-right: 3px solid #ff00ff;
        }

        /* 故障文字效果 */
        .cyber-title {
            font-size: 48px;
            color: #fff;
            margin: 0;
            text-transform: uppercase;
            position: relative;
            text-shadow: 2px 2px 0px #ff00ff, -2px -2px 0px #00f3ff;
            animation: glitch-anim 2.5s infinite linear alternate-reverse;
            letter-spacing: 4px;
        }

        .cyber-title::before, .cyber-title::after {
            content: attr(data-text);
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; 
        }
        .cyber-title::before {
            left: 2px; text-shadow: -1px 0 #ff00ff;
            clip-path: inset(0 0 0 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }
        .cyber-title::after {
            left: -2px; text-shadow: -1px 0 #00f3ff;
            clip-path: inset(0 0 0 0);
            animation: glitch-anim-2 2s infinite linear alternate-reverse;
        }

        .cyber-divider {
            width: 100%; height: 2px; background: linear-gradient(90deg, transparent, #00f3ff, transparent);
            margin: 20px 0;
            box-shadow: 0 0 10px #00f3ff;
        }

        .cyber-stat {
            font-size: 16px; color: #fsee00; margin: 20px 0;
            letter-spacing: 2px; text-shadow: 0 0 8px rgba(247, 238, 0, 0.6);
            transform: skewX(5deg); /* 反向倾斜文字以保持直立 */
        }

        /* 赛博朋克按钮 */
        .cyber-btn {
            background: transparent;
            border: 2px solid #ff00ff;
            color: #ff00ff;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            position: relative;
            transition: 0.2s;
            margin-top: 10px;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
            /* 切角按钮 */
            clip-path: polygon(15% 0, 100% 0, 100% 70%, 85% 100%, 0 100%, 0 30%);
        }

        .cyber-btn:hover {
            background: #ff00ff;
            color: #000;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.8), inset 0 0 10px #fff;
            transform: scale(1.05);
            text-shadow: none;
        }
        
        .cyber-btn:active {
            transform: scale(0.95);
        }

        /* 动画定义 */
        @keyframes scrollScanlines { from { background-position: 0 0; } to { background-position: 0 100%; } }

        @keyframes glitch-anim {
            0% { text-shadow: 2px 2px #ff00ff, -2px -2px #00f3ff; transform: translate(0); }
            20% { text-shadow: -2px 2px #ff00ff, 2px -2px #00f3ff; transform: translate(-2px, 2px); }
            40% { text-shadow: 2px -2px #ff00ff, -2px 2px #00f3ff; transform: translate(2px, -2px); }
            60% { text-shadow: -2px -2px #ff00ff, 2px 2px #00f3ff; transform: translate(-2px, -2px); }
            80% { text-shadow: 2px 2px #ff00ff, -2px -2px #00f3ff; transform: translate(2px, 2px); }
            100% { text-shadow: -2px 2px #ff00ff, 2px -2px #00f3ff; transform: translate(0); }
        }

        @keyframes glitch-anim-2 {
            0% { clip-path: inset(10% 0 80% 0); }
            20% { clip-path: inset(80% 0 1% 0); }
            40% { clip-path: inset(40% 0 20% 0); }
            60% { clip-path: inset(10% 0 60% 0); }
            80% { clip-path: inset(30% 0 30% 0); }
            100% { clip-path: inset(70% 0 20% 0); }
        }

        .art-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .hero-art { position: absolute; bottom: 0; left: 2%; height: 85vh; width: auto; max-width: 45vw; object-fit: contain; filter: drop-shadow(0 0 30px rgba(160, 32, 240, 0.3)); animation: floatHero 6s ease-in-out infinite; z-index: 2; }
        .boss-art { position: absolute; bottom: 0; right: 2%; height: 90vh; width: auto; max-width: 45vw; object-fit: contain; filter: drop-shadow(0 0 30px rgba(255, 50, 50, 0.4)); animation: floatBoss 7s ease-in-out infinite; z-index: 2; }
        .scene-art { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 1; mix-blend-mode: normal; z-index: 0; }
        
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%); opacity: 0; pointer-events: none; transition: opacity 0.1s; z-index: 5; mix-blend-mode: overlay; }
        #frenzy-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 30%, rgba(120, 0, 200, 0.4) 100%); opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 4; mix-blend-mode: hard-light; }

        @keyframes pulseGlow { 0% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); border-color: #a020f0; color: #a020f0; transform: skewX(10deg) scale(1); } 50% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.8), inset 0 0 10px rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff; text-shadow: 0 0 10px #00ffff; transform: skewX(10deg) scale(1.05); } 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); border-color: #a020f0; color: #a020f0; transform: skewX(10deg) scale(1); } }
        @keyframes buttonFlash { 0% { filter: brightness(1) drop-shadow(0 0 5px rgba(255,255,255,0.2)); transform: scale(1); } 50% { filter: brightness(1.3) drop-shadow(0 0 15px rgba(255,255,255,0.6)); transform: scale(1.02); } 100% { filter: brightness(1) drop-shadow(0 0 5px rgba(255,255,255,0.2)); transform: scale(1); } }
        @keyframes floatHero { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes floatBoss { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        #loading-box {
            position: absolute;
            bottom: 25%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 300px;
            z-index: 25;
            text-align: center;
        }

        #loading-text {
            color: #00ffff;
            font-size: 12px;
            margin-bottom: 10px;
            text-shadow: 0 0 5px #00ffff;
            letter-spacing: 2px;
            animation: blinkText 1s infinite;
        }

        @keyframes blinkText { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #loading-bar-border {
            width: 100%;
            height: 20px;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            padding: 2px;
            transform: skewX(-15deg);
        }

        #loading-bar-fill {
            width: 0%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                #00aaaa,
                #00aaaa 10px,
                #00ffff 10px,
                #00ffff 20px
            );
            box-shadow: 0 0 10px #00ffff;
            transition: width 0.2s ease-out;
        }

        #start-btn { 
            display: none; 
            cursor: pointer; 
            z-index: 20; 
            max-width: 200px;
            width: 40vw;
            height: auto;
            animation: buttonFlash 1.5s infinite ease-in-out;
            transition: all 0.1s;
            -webkit-user-drag: none;
            margin-top: 30vh;
        }

        .fade-in {
            animation: fadeIn 0.5s forwards, buttonFlash 1.5s infinite ease-in-out !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        #start-btn:active { 
            animation: none; 
            filter: hue-rotate(90deg) brightness(0.8) !important; 
            transform: scale(0.9); 
        }

        .hidden { display: none !important; }
        
        #mobile-controls { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; pointer-events: auto; }
        .d-pad { position: absolute; bottom: 30px; left: 30px; display: flex; gap: 15px; }
        .action-pad { position: absolute; bottom: 30px; right: 30px; display: flex; gap: 15px; }
        .ctrl-btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: white; font-size: 20px; display: flex; justify-content: center; align-items: center; user-select: none; }
        .skill-btn-mobile { border-color: #00ffff; color: #00ffff; }
        
        @media screen and (max-width: 400px) { #health-bar-container { width: 200px; } #energy-bar-container { width: 160px; } }

        .dash-icon-container {
            position: relative;
            width: 30px;
            height: 30px;
            margin-top: 4px;
            margin-left: 2px;
        }
        .dash-square {
            position: absolute;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, rgba(0,255,255,0.4), rgba(0,255,255,0.9));
            border: 1px solid rgba(255,255,255,0.8);
            transform: skewX(-15deg);
            box-shadow: 0 0 2px rgba(0,255,255,0.5);
        }
        .dash-square:nth-child(1) { left: 0px; top: 8px; opacity: 0.4; z-index: 1; }
        .dash-square:nth-child(2) { left: 8px; top: 8px; opacity: 0.7; z-index: 2; }
        .dash-square:nth-child(3) { left: 16px; top: 8px; opacity: 1.0; z-index: 3; box-shadow: 0 0 6px #00ffff; background: linear-gradient(135deg, rgba(0,255,255,0.8), #fff); }

        /* 新增：雪花技能图标样式 */
        .freeze-icon {
            width: 30px; 
            height: 30px;
            position: relative;
            animation: spinSlow 6s linear infinite;
        }
        .flake-line {
            position: absolute;
            left: 50%;
            top: 0;
            width: 3px;
            height: 100%;
            background: #00ffff;
            border-radius: 2px;
            box-shadow: 0 0 5px #00ffff;
            transform: translateX(-50%);
        }
        /* 三条线交叉形成雪花 */
        .flake-line:nth-child(2) { transform: translateX(-50%) rotate(60deg); }
        .flake-line:nth-child(3) { transform: translateX(-50%) rotate(-60deg); }
        
        @keyframes spinSlow { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        @media (hover: none) and (pointer: coarse) { #mobile-controls { display: block; } .desktop-hint { display: none; } }
        @media screen and (max-width: 768px) { #mobile-controls { display: block; } .desktop-hint { display: none; } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="damage-overlay"></div>
    <div id="frenzy-overlay"></div>
    
    <div id="ui-layer">
        <div class="hud">
            <div class="hud-left">
                <div class="hud-row">
                    <div id="health-bar-container"><div id="health-fill"></div></div>
                    <div id="skill-container" class="hidden">
                        <!-- 修改：更新为雪花HTML结构 -->
                        <div id="skill-icon">
                            <div class="freeze-icon">
                                <div class="flake-line"></div>
                                <div class="flake-line"></div>
                                <div class="flake-line"></div>
                            </div>
                            <div id="skill-timer"></div>
                        </div>
                        <div id="skill-label">FREEZE (E)</div>
                    </div>
                </div>
                
                <div id="energy-bar-container"><div id="energy-fill"></div><div id="energy-text">FRENZY MODE!</div></div>
                <div id="cells-count">KILLS: 0</div>
                <div id="status-panel">ATK SPEED: 100%<br>MOV SPEED: 100%</div>
            </div>
            <div class="hud-right">
                <div id="dist-display">DIST: 0m</div>
                <div id="danger-display">DANGER: 1.0x</div>
            </div>
        </div>
        
        <div class="desktop-hint">
            WASD/ARROWS: MOVE | SPACE/K: JUMP | J/CLICK: ATTACK | DOWN+J: PLUNGE | E: FREEZE | SHIFT: DASH
        </div>
        <div id="mobile-controls">
            <div class="d-pad">
                <div class="ctrl-btn" id="btn-left">←</div>
                <div class="ctrl-btn" id="btn-down">↓</div>
                <div class="ctrl-btn" id="btn-right">→</div>
            </div>
            <div class="action-pad">
                <div class="ctrl-btn skill-btn-mobile" id="btn-skill">
                    <!-- 修改：更新为雪花HTML结构 -->
                    <div class="freeze-icon">
                        <div class="flake-line"></div>
                        <div class="flake-line"></div>
                        <div class="flake-line"></div>
                    </div>
                </div>
                <div class="ctrl-btn" id="btn-dash">
                    <div class="dash-icon-container">
                        <div class="dash-square"></div>
                        <div class="dash-square"></div>
                        <div class="dash-square"></div>
                    </div>
                </div>
                <div class="ctrl-btn large-btn" id="btn-attack">⚔️</div>
                <div class="ctrl-btn" id="btn-jump">▲</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="art-layer">
            <img src="bg.gif" class="scene-art" alt="" onerror="this.style.display='none'">
            <img src="hero.gif" class="hero-art" alt="" onerror="this.style.display='none'">
            <img src="boss.gif" class="boss-art" alt="" onerror="this.style.display='none'">
        </div>
        
        <div id="loading-box">
            <div id="loading-text">INITIALIZING... 0%</div>
            <div id="loading-bar-border">
                <div id="loading-bar-fill"></div>
            </div>
        </div>
        <img id="start-btn" src="button.png" alt="Start Game">
    </div>

    <!-- ====================================================== -->
    <!-- NEW CYBERPUNK GAME OVER SCREEN -->
    <!-- ====================================================== -->
    <div id="game-over-screen" class="hidden">
        <!-- 扫描线效果层 -->
        <div class="scanlines"></div>
        
        <!-- 赛博朋克风格 UI 框 -->
        <div class="cyber-box">
            <!-- 故障风格标题，data-text 用于 CSS 伪元素动画 -->
            <h1 class="cyber-title" data-text="TERMINATED">TERMINATED</h1>
            
            <div class="cyber-divider"></div>
            
            <p id="final-score" class="cyber-stat">DISTANCE: 0m</p>
            
            <button id="restart-btn" class="cyber-btn">REBOOT SYSTEM</button>
        </div>
    </div>

    <script>
        const SPRITE_CONFIG = {
            hero: { idle: {src:'hero_idle.png',frames:6}, run: {src:'hero_run.png',frames:8}, jump: {src:'hero_jump.png',frames:4}, dash: {src:'hero_dash.png',frames:4}, attack_1: {src:'hero_attack_1.png',frames:8}, attack_2: {src:'hero_attack_2.png',frames:3}, attack_3: {src:'hero_attack_3.png',frames:5}, skill: {src:'hero_skill.png',frames:3}, plunge: {src:'hero_plunge.png',frames:1} },
            enemy: { idle: {src:'enemy_idle.png',frames:4}, walk: {src:'enemy_walk.png',frames:6}, attack: {src:'enemy_attack.png',frames:5} },
            medium_enemy: { idle: {src:'enemy_medium_idle.png',frames:4}, walk: {src:'enemy_medium_walk.png',frames:6}, attack: {src:'enemy_medium_attack.png',frames:5} },
            bat: { fly: {src:'bat_fly.png',frames:4} },
            effects: { grenade: {src:'grenade.png',frames:3}, explosion: {src:'explosion.png',frames:8}, impact: {src:'effect_impact.png',frames:6} }
        };
        const assets = { hero: {}, enemy: {}, medium_enemy: {}, bat: {}, effects: {} };
        const groundImage = new Image(); 
        const bgImage = new Image(); 
        
        let assetsLoadedCount = 0;
        let totalAssetsCount = 0;
        totalAssetsCount = 2; 
        for (const cat in SPRITE_CONFIG) {
            totalAssetsCount += Object.keys(SPRITE_CONFIG[cat]).length;
        }

        function updateLoadingProgress() {
            assetsLoadedCount++;
            const percent = Math.min(Math.floor((assetsLoadedCount / totalAssetsCount) * 100), 100);
            
            const barFill = document.getElementById('loading-bar-fill');
            const loadText = document.getElementById('loading-text');
            const loadBox = document.getElementById('loading-box');
            const startBtn = document.getElementById('start-btn');

            if (barFill) barFill.style.width = percent + '%';
            if (loadText) loadText.innerText = `LOADING SYSTEM... ${percent}%`;

            if (assetsLoadedCount >= totalAssetsCount) {
                setTimeout(() => {
                    if (loadBox) loadBox.style.display = 'none'; 
                    if (startBtn) {
                        startBtn.style.display = 'block'; 
                        startBtn.classList.add('fade-in'); 
                    }
                }, 200);
            }
        }

        const onAssetEvent = () => { updateLoadingProgress(); };

        groundImage.onload = onAssetEvent; groundImage.onerror = onAssetEvent;
        bgImage.onload = onAssetEvent; bgImage.onerror = onAssetEvent;

        groundImage.src = 'ground.png';
        bgImage.src = 'bg.png';

        function loadSprites() {
            const loadCategory = (category, targetObj) => { 
                for (const [key, config] of Object.entries(category)) { 
                    const img = new Image(); 
                    img.onload = onAssetEvent;
                    img.onerror = onAssetEvent;
                    img.src = config.src; 
                    targetObj[key] = { img, frames: config.frames }; 
                } 
            };
            loadCategory(SPRITE_CONFIG.hero, assets.hero); 
            loadCategory(SPRITE_CONFIG.enemy, assets.enemy); 
            loadCategory(SPRITE_CONFIG.medium_enemy, assets.medium_enemy); 
            loadCategory(SPRITE_CONFIG.bat, assets.bat); 
            loadCategory(SPRITE_CONFIG.effects, assets.effects);
        }
        loadSprites();

        const tintCanvas = document.createElement('canvas');
        tintCanvas.width = 300; 
        tintCanvas.height = 300;
        const tintCtx = tintCanvas.getContext('2d');

        const CONFIG = { gravity: 0.8, friction: 0.85, playerSpeed: 9, jumpForce: 21, dashSpeed: 30, dashDuration: 12, colors: { player: '#a020f0', enemy: '#50a030', enemyMedium: '#a03030', bg: '#0d0d15', platform: '#1a1a2e', platformHighlight: '#333355' } };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let gameState = 'MENU';
        let width, height;
        let score = 0, killStreak = 0, distance = 0, dangerLevel = 1.0;
        let camera = { x: 0, y: 0, shake: 0 };
        let lastGeneratedX = 0, lastGeneratedY = 0, groundPattern = null, hitStop = 0;
        let chests = [], pickups = [], grenades = [], impactEffects = [], wanderingSoul = null, souls = [];
        let platforms = [], enemies = [], particles = [], floatingTexts = [];
        let player;
        let lastFrameTime = 0; 
        const targetFPS = 60, frameInterval = 1000 / targetFPS;
        const keys = { left: false, right: false, up: false, down: false, jump: false, attack: false, dash: false, skill: false };

        function resize() { 
            const targetWidth = 1300; 
            let scale = window.innerWidth < targetWidth ? (targetWidth / window.innerWidth) : 1;
            scale = Math.min(4.0, scale);
            width = canvas.width = window.innerWidth * scale; 
            height = canvas.height = window.innerHeight * scale; 
            ctx.imageSmoothingEnabled = false; 
        }
        window.addEventListener('resize', resize); resize();
        function rand(min, max) { return Math.random() * (max - min) + min; }
        function checkRectCollide(r1, r2) { return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y; }

        class Soul {
            constructor(x, y, amount) {
                this.x = x; this.y = y; this.amount = amount;
                this.vx = (Math.random() - 0.5) * 12; this.vy = (Math.random() - 0.5) * 12 - 5;
                this.timer = 0; this.dead = false;
            }
            update(player) {
                this.timer++;
                if (this.timer < 25) { 
                    this.x += this.vx; this.y += this.vy; this.vy += 0.8; this.vx *= 0.92;
                } else {
                    let targetX = player.x + player.w/2; let targetY = player.y + player.h/2;
                    let dx = targetX - this.x; let dy = targetY - this.y;
                    let dist = Math.sqrt(dx*dx + dy*dy);
                    let speed = 25; 
                    this.vx = this.vx * 0.8 + (dx / dist) * speed * 0.2;
                    this.vy = this.vy * 0.8 + (dy / dist) * speed * 0.2;
                    this.x += this.vx; this.y += this.vy;
                    if (dist < 50) { player.addEnergy(this.amount); this.dead = true; createParticles(this.x, this.y, '#aa00ff', 5, 5); }
                }
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                ctx.save(); ctx.translate(this.x - cx, this.y - cy);
                ctx.fillStyle = '#d0f'; ctx.shadowBlur = 10; ctx.shadowColor = '#d0f'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill(); ctx.restore();
            }
        }

        class ImpactEffect {
            constructor(x, y) { this.x = x; this.y = y; this.timer = 0; this.maxFrame = (assets.effects.impact && assets.effects.impact.frames) || 6; this.dead = false; }
            update() { this.timer += 0.3; if (this.timer >= this.maxFrame) this.dead = true; }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let info = assets.effects.impact;
                if (info && info.img.complete && info.img.naturalWidth !== 0) {
                    let f = Math.floor(this.timer);
                    if (f >= info.frames) f = info.frames - 1;
                    let sw = info.img.width / info.frames;
                    let sz = sw * 3;
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, this.x - cx - sz / 2, this.y - cy - sz + 20, sz, sz);
                }
            }
        }

        // 新增：攻击时的刀光特效类
        class SlashEffect {
            constructor(x, y, facingRight, isFrenzy) {
                this.x = x; this.y = y; this.facingRight = facingRight;
                this.life = 0; this.maxLife = 10; // 持续时间
                this.color = isFrenzy ? '#d0f' : '#0ff';
                this.width = 0;
            }
            update() { 
                this.life++; 
                // 刀光跟随方向稍微移动
                this.x += this.facingRight ? 5 : -5; 
                if(this.life >= this.maxLife) this.dead = true;
            }
            draw(ctx, cx, cy) {
                if(this.dead) return;
                let alpha = 1 - (this.life / this.maxLife);
                ctx.save();
                ctx.translate(this.x - cx, this.y - cy);
                if (!this.facingRight) ctx.scale(-1, 1);
                
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                
                // 绘制月牙形状的刀光
                ctx.beginPath();
                // 外弧
                ctx.moveTo(0, -60);
                ctx.quadraticCurveTo(60, 0, 0, 60);
                // 内弧
                ctx.quadraticCurveTo(40, 0, 0, -60);
                ctx.fill();
                
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        class WanderingSoul {
            constructor(x, y) { this.x = x; this.y = y; this.timer = 0; this.angle = Math.random() * Math.PI * 2; this.speed = 0.5; }
            update() {
                this.timer++; this.angle += (Math.random() - 0.5) * 0.05;
                this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed;
                if (this.x < 50) this.angle = 0; if (this.x > width - 50) this.angle = Math.PI;
                if (this.y < 50) this.angle = Math.PI / 2; if (this.y > height - 50) this.angle = -Math.PI / 2;
            }
            draw(ctx) {
                ctx.save();
                for (let i = 1; i <= 15; i++) {
                    let a = 1 - (i / 15); ctx.fillStyle = `rgba(0,255,255,${a * 0.5})`;
                    ctx.beginPath(); ctx.arc(this.x + (Math.random() - 0.5) * 20, this.y - (i * 5 + Math.random() * 5), Math.random() * 3 + 2, 0, Math.PI * 2); ctx.fill();
                }
                let r = 25 + Math.sin(this.timer * 0.05) * 2;
                ctx.shadowBlur = 20; ctx.shadowColor = "#00ffff"; ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(this.x + r * 0.3, this.y - r * 0.3, r * 0.25, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, c, s, sz, l) { this.x = x; this.y = y; this.c = c; this.vx = (Math.random() - 0.5) * s; this.vy = (Math.random() - 0.5) * s; this.sz = sz * 1.5; this.l = l; this.ml = l; }
            update() { this.x += this.vx; this.y += this.vy; this.l--; this.sz *= 0.95; }
            draw(ctx, cx, cy) { ctx.globalAlpha = this.l / this.ml; ctx.fillStyle = this.c; ctx.fillRect(this.x - cx, this.y - cy, this.sz, this.sz); ctx.globalAlpha = 1; }
        }

        class FloatingText {
            constructor(x, y, t, c, s = 24) { this.x = x; this.y = y; this.t = t; this.c = c; this.l = 60; this.vy = -1; this.s = s; }
            update() { this.y += this.vy; this.l--; }
            draw(ctx, cx, cy) { ctx.globalAlpha = Math.max(0, this.l / 60); ctx.fillStyle = this.c; ctx.font = `${this.s}px 'Press Start 2P'`; ctx.fillText(this.t, this.x - cx, this.y - cy); ctx.globalAlpha = 1; }
        }

        class Entity {
            constructor(x, y, w, h, c) { this.x = x; this.y = y; this.w = w; this.h = h; this.vx = 0; this.vy = 0; this.color = c; this.grounded = false; this.facingRight = true; this.hp = 100; this.maxHp = 100; this.dead = false; this.state = 'idle'; this.gameFrame = 0; this.staggerFrames = 8; this.currentPlatform = null; }
            update(platforms) {
                if (this.dead) return;
                this.vy += CONFIG.gravity;
                this.x += this.vx;
                for (let p of platforms) { if (checkRectCollide(this, p)) { if (this.vx > 0) { this.x = p.x - this.w; this.vx = 0; } else if (this.vx < 0) { this.x = p.x + p.w; this.vx = 0; } } }
                if (this.grounded) this.vx *= CONFIG.friction; else this.vx *= 0.95;
                this.y += this.vy; this.grounded = false; this.currentPlatform = null;
                for (let p of platforms) {
                    if (checkRectCollide(this, p)) {
                        if (this.vy > 0) {
                            this.y = p.y - this.h; this.vy = 0; this.grounded = true; this.currentPlatform = p;
                            if (p.depressionOffset > 0) { p.depressionTimer--; if (p.depressionTimer <= 0) { p.depressionOffset *= 0.9; if (p.depressionOffset < 0.1) p.depressionOffset = 0; } }
                        } else if (this.vy < 0) { this.y = p.y + p.h; this.vy = 0; }
                    }
                }
                if (this.y > 3000) this.takeDamage(9999);
                this.gameFrame++;
            }
            takeDamage(a) { this.hp -= a; if (this.hp <= 0) this.dead = true; }
            draw(ctx, cx, cy) { if (this.dead) return; ctx.fillStyle = this.color; ctx.fillRect(this.x - cx, this.y - cy, this.w, this.h); }
        }

        class Grenade extends Entity {
            constructor(x, y, tx, ty, owner) {
                super(x, y, 20, 20, '#000'); this.owner = owner; let t = 100; let g = CONFIG.gravity * 0.5;
                const dx = tx - x; const dy = ty - y;
                this.vx = dx / t; this.vy = (dy - 0.5 * g * t * t) / t;
                this.state = 'flying'; this.explodeTimer = 0;
            }
            update(platforms, player) {
                if (this.dead) return;
                if (this.state === 'flying') {
                    this.vy += CONFIG.gravity * 0.5; this.x += this.vx; this.y += this.vy;
                    for (let p of platforms) if (checkRectCollide(this, p)) return this.explode(player);
                    if (checkRectCollide(this, player)) return this.explode(player);
                    this.gameFrame++;
                } else if (this.state === 'exploding') {
                    this.explodeTimer += 0.4; if (this.explodeTimer >= assets.effects.explosion.frames) this.dead = true;
                }
            }
            destroy() { if (this.state !== 'flying') return; this.dead = true; createParticles(this.x + 10, this.y + 10, '#ccc', 10, 15); floatingTexts.push(new FloatingText(this.x, this.y - 20, "DEFLECT!", "#fff", 20)); }
            explode(player) {
                if (this.state !== 'flying') return; this.state = 'exploding'; this.vx = 0; this.vy = 0; camera.shake = 20;
                if (Math.hypot((this.x + 10) - (player.x + player.w / 2), (this.y + 10) - (player.y + player.h / 2)) < 150) {
                    player.takeDamage(60); player.vx = (player.x < this.x ? -15 : 15); player.vy = -10;
                }
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let info = this.state === 'flying' ? assets.effects.grenade : assets.effects.explosion;
                if (info && info.img && info.img.complete && info.img.naturalWidth !== 0) {
                    let f = this.state === 'flying' ? (Math.floor(this.gameFrame / 5) % info.frames) : Math.floor(this.explodeTimer);
                    if (f >= info.frames) f = info.frames - 1;
                    let sc = this.state === 'flying' ? 2 : 4;
                    let sw = info.img.width / info.frames; let d = sw * sc;
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, this.x - cx - d / 2 + 10, this.y - cy - d / 2 + 10, d, d);
                } else { ctx.fillStyle = this.state === 'flying' ? '#555' : '#fa0'; ctx.fillRect(this.x - cx, this.y - cy, 20, 20); }
            }
        }

        class BatEnemy extends Entity {
            constructor(x, y, dS = 1, hS = 1) {
                super(x, y, 80, 60, '#550000'); this.maxHp = 20 * hS; this.hp = this.maxHp; this.damage = 5 * dS; this.state = 'fly'; this.spriteScale = 2;
                this.frozen = false; this.freezeTimer = 0; this.bobTimer = rand(0, 100); this.baseY = y; this.startX = x; this.patrolDist = 150; this.vx = 1.5;
            }
            freeze(d = 300) { this.frozen = true; this.freezeTimer = d; }
            update(plat, p) {
                if (this.dead) return;
                if (this.frozen) { if (--this.freezeTimer <= 0) this.frozen = false; return; }
                this.bobTimer += 0.05;
                if (this.x > this.startX + this.patrolDist) { this.vx = -1.5; this.facingRight = false; }
                else if (this.x < this.startX - this.patrolDist) { this.vx = 1.5; this.facingRight = true; }
                this.x += this.vx; this.y = this.baseY + Math.sin(this.bobTimer) * 15;
                if (checkRectCollide(this, p) && p.hp > 0 && !p.isDashing) p.takeDamage(this.damage);
                this.gameFrame++;
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let info = assets.bat.fly;
                if (info && info.img && info.img.complete && info.img.naturalWidth !== 0) {
                    let f = Math.floor(this.gameFrame / 5) % info.frames;
                    ctx.save(); ctx.translate(this.x - cx + this.w / 2, this.y - cy + this.h / 2);
                    if (!this.facingRight) ctx.scale(-1, 1);
                    
                    let sw = info.img.width / info.frames; let dw = sw * this.spriteScale; let dh = info.img.height * this.spriteScale;
                    
                    if (this.frozen) ctx.filter = 'sepia(1) hue-rotate(170deg) saturate(3) brightness(1.2)';
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, -dw / 2, -dh / 2, dw, dh);
                    ctx.filter = 'none';

                    if (this.frozen) {
                        tintCtx.clearRect(0, 0, dw, dh);
                        tintCtx.drawImage(info.img, f * sw, 0, sw, info.img.height, 0, 0, dw, dh);
                        tintCtx.globalCompositeOperation = 'source-in';
                        tintCtx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                        tintCtx.fillRect(0, 0, dw, dh);
                        tintCtx.globalCompositeOperation = 'source-over';
                        
                        ctx.drawImage(tintCanvas, 0, 0, dw, dh, -dw / 2, -dh / 2, dw, dh);
                    }

                    ctx.restore();
                } else { super.draw(ctx, cx, cy); }
            }
            takeDamage(a) {
                this.hp -= a;
                if (this.hp <= 0) {
                    this.hp = 0; this.dead = true; score++; 
                    player.addEnergy(10); 
                    killStreak++;
                    if (killStreak >= 5) { killStreak = 0; Math.random() > 0.5 ? player.upgrade('attack') : player.upgrade('speed'); }
                    document.getElementById('cells-count').innerText = "KILLS: " + score;
                    createParticles(this.x + this.w / 2, this.y + this.h / 2, '#500', 10, 20);
                }
            }
        }

        class MediumEnemy extends Entity {
            constructor(x, y, dS = 1, hS = 1) {
                super(x, y, 100, 100, CONFIG.colors.enemyMedium); this.maxHp = 200 * hS; this.hp = this.maxHp; this.damage = 25 * dS;
                this.state = 'idle'; this.detectRange = 600; this.attackTimer = 0; this.isAttacking = false;
                this.spriteScale = 3.0; this.frozen = false; this.freezeTimer = 0; this.grenadeCooldown = 0;
            }
            freeze(d = 300) { this.frozen = true; this.freezeTimer = d; this.vx = 0; }
            update(plat, p) {
                if (this.dead) return;
                if (this.frozen) { if (--this.freezeTimer <= 0) this.frozen = false; super.update(plat); return; }
                super.update(plat);
                if (this.grenadeCooldown > 0) this.grenadeCooldown--;
                if (p.isDying || p.dead || p.isSpawning) { this.state = 'idle'; this.vx *= 0.8; return; }
                let dist = Math.abs(p.x - this.x); let dy = Math.abs(p.y - this.y);
                if (this.isAttacking) {
                    this.state = 'attack'; if (this.attackTimer > 0) this.attackTimer--; if (this.attackTimer <= 0) this.isAttacking = false;
                } else {
                    if (dist < this.detectRange && dy < 200) {
                        if (this.grenadeCooldown <= 0 && Math.random() < 0.02) this.throwGrenade(p);
                        this.state = 'walk';
                        if (p.x > this.x + 10) { this.vx = 0.8; this.facingRight = true; } else if (p.x < this.x - 10) { this.vx = -0.8; this.facingRight = false; } else this.vx = 0;
                        if (checkRectCollide(this, p) && p.hp > 0) {
                            this.isAttacking = true; this.attackTimer = 80;
                            if (!p.isDashing) { p.takeDamage(this.damage); p.vy = -10; p.vx = this.vx * 10; camera.shake = 15; createParticles(p.x + p.w / 2, p.y, '#f00', 8, 8); }
                        }
                    } else { this.state = 'idle'; this.vx *= 0.8; }
                }
            }
            throwGrenade(p) { grenades.push(new Grenade(this.x + this.w / 2, this.y, p.x, p.y, this)); this.grenadeCooldown = 180; }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let dx = this.x - cx; let dy = this.y - cy;
                let info = assets.medium_enemy[this.state] || assets.enemy[this.state] || assets.enemy.idle;
                let has = info && info.img && info.img.complete && info.img.naturalWidth !== 0;
                if (!has) { super.draw(ctx, cx, cy); } else {
                    let f = Math.floor(this.gameFrame / 15) % info.frames;
                    ctx.save(); ctx.translate(dx + this.w / 2, dy + this.h / 2); if (!this.facingRight) ctx.scale(-1, 1);
                    
                    let sw = info.img.width / info.frames; let dsz = sw * this.spriteScale;
                    let vy = (this.h / 2) - dsz;
                    
                    if (this.frozen) ctx.filter = 'sepia(1) hue-rotate(170deg) saturate(3) brightness(1.2)';
                    else if (!assets.medium_enemy[this.state] || !assets.medium_enemy[this.state].img.complete) ctx.filter = 'hue-rotate(-50deg) brightness(0.8)';
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, -dsz / 2, vy, dsz, dsz);
                    ctx.filter = 'none';

                    if (this.frozen) {
                        tintCtx.clearRect(0, 0, dsz, dsz);
                        tintCtx.drawImage(info.img, f * sw, 0, sw, info.img.height, 0, 0, dsz, dsz);
                        tintCtx.globalCompositeOperation = 'source-in';
                        tintCtx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                        tintCtx.fillRect(0, 0, dsz, dsz);
                        tintCtx.globalCompositeOperation = 'source-over';

                        ctx.drawImage(tintCanvas, 0, 0, dsz, dsz, -dsz / 2, vy, dsz, dsz);
                    }

                    ctx.restore();
                    let hr = this.hp / this.maxHp;
                    let by = dy + this.h - dsz - 5 - 20; 
                    if (this.grounded && this.currentPlatform && this.currentPlatform.depressionOffset > 0) by += this.currentPlatform.depressionOffset;
                    ctx.fillStyle = 'red'; ctx.fillRect(dx, by - 20, 100, 10);
                    ctx.fillStyle = hr < 0.2 ? '#f00' : (hr < 0.5 ? '#ff0' : '#0f0'); ctx.fillRect(dx, by - 20, 100 * hr, 10);
                }
            }
            takeDamage(a) {
                this.hp -= a;
                if (this.hp <= 0) {
                    this.hp = 0; this.dead = true; score += 2; 
                    for(let i=0; i<10; i++) souls.push(new Soul(this.x + this.w/2, this.y + this.h/2, 2));
                    killStreak += 2;
                    if (killStreak >= 5) { killStreak = 0; Math.random() > 0.5 ? player.upgrade('attack') : player.upgrade('speed'); }
                    document.getElementById('cells-count').innerText = "KILLS: " + score;
                    createParticles(this.x + this.w / 2, this.y + this.h / 2, CONFIG.colors.enemyMedium, 20, 40);
                }
            }
        }
        class Enemy extends Entity {
            constructor(x, y, dS = 1, hS = 1) {
                super(x, y, 60, 60, CONFIG.colors.enemy); this.maxHp = 50 * hS; this.hp = this.maxHp; this.damage = 10 * dS;
                this.state = 'idle'; this.detectRange = 500; this.attackTimer = 0; this.isAttacking = false;
                this.spriteScale = 2.0; this.frozen = false; this.freezeTimer = 0;
            }
            freeze(d = 300) { this.frozen = true; this.freezeTimer = d; this.vx = 0; }
            update(plat, p) {
                if (this.dead) return;
                if (this.frozen) { if (--this.freezeTimer <= 0) this.frozen = false; super.update(plat); return; }
                super.update(plat);
                if (p.isDying || p.dead || p.isSpawning) { this.state = 'idle'; this.vx *= 0.8; return; }
                let dist = Math.abs(p.x - this.x); let dy = Math.abs(p.y - this.y);
                if (this.isAttacking) {
                    this.state = 'attack'; if (this.attackTimer > 0) this.attackTimer--; if (this.attackTimer <= 0) this.isAttacking = false;
                } else {
                    if (dist < this.detectRange && dy < 150) {
                        this.state = 'walk';
                        if (p.x > this.x + 10) { this.vx = 2.5; this.facingRight = true; } else if (p.x < this.x - 10) { this.vx = -2.5; this.facingRight = false; } else this.vx = 0;
                        if (checkRectCollide(this, p) && p.hp > 0) {
                            this.isAttacking = true; this.attackTimer = 40;
                            if (!p.isDashing) { p.takeDamage(this.damage); p.vy = -8; p.vx = this.vx * 5; camera.shake = 8; createParticles(p.x + p.w / 2, p.y, '#f00', 5, 5); }
                        }
                    } else { this.state = 'idle'; this.vx *= 0.8; }
                }
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let dx = this.x - cx; let dy = this.y - cy;
                let info = assets.enemy[this.state] || assets.enemy.idle;
                let has = info && info.img && info.img.complete && info.img.naturalWidth !== 0;
                if (!has) { super.draw(ctx, cx, cy); } else {
                    let f = Math.floor(this.gameFrame / 10) % info.frames;
                    ctx.save(); ctx.translate(dx + this.w / 2, dy + this.h / 2); if (!this.facingRight) ctx.scale(-1, 1);
                    
                    let sw = info.img.width / info.frames; 
                    let dsz = sw * this.spriteScale;
                    let vy = (this.h / 2) - dsz;
                    
                    if (this.frozen) ctx.filter = 'sepia(1) hue-rotate(170deg) saturate(3) brightness(1.2)';
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, -dsz / 2, vy, dsz, dsz);
                    ctx.filter = 'none';

                    if (this.frozen) {
                        tintCtx.clearRect(0, 0, dsz, dsz);
                        tintCtx.drawImage(info.img, f * sw, 0, sw, info.img.height, 0, 0, dsz, dsz);
                        tintCtx.globalCompositeOperation = 'source-in';
                        tintCtx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                        tintCtx.fillRect(0, 0, dsz, dsz);
                        tintCtx.globalCompositeOperation = 'source-over';

                        ctx.drawImage(tintCanvas, 0, 0, dsz, dsz, -dsz / 2, vy, dsz, dsz);
                    }

                    ctx.restore();
                    
                    let hr = this.hp / this.maxHp;
                    let barY = dy + this.h - dsz - 5 - 12;
                    if (this.grounded && this.currentPlatform && this.currentPlatform.depressionOffset > 0) barY += this.currentPlatform.depressionOffset;
                    
                    ctx.fillStyle = 'red'; ctx.fillRect(dx, barY, 60, 8);
                    ctx.fillStyle = hr < 0.2 ? '#f00' : (hr < 0.5 ? '#ff0' : '#0f0'); ctx.fillRect(dx, barY, 60 * hr, 8);
                }
            }
            takeDamage(a) {
                this.hp -= a;
                if (this.hp <= 0) {
                    this.hp = 0; this.dead = true; score++; 
                    for(let i=0; i<5; i++) souls.push(new Soul(this.x + this.w/2, this.y + this.h/2, 2));
                    killStreak++;
                    if (killStreak >= 5) { killStreak = 0; Math.random() > 0.5 ? player.upgrade('attack') : player.upgrade('speed'); }
                    document.getElementById('cells-count').innerText = "KILLS: " + score;
                    createParticles(this.x + this.w / 2, this.y + this.h / 2, CONFIG.colors.enemy, 15, 30);
                }
            }
        }
        class Chest extends Entity {
            constructor(x, y) { super(x, y, 40, 40, '#ffd700'); this.opened = false; }
            draw(ctx, cx, cy) {
                if (this.opened) return;
                let dy = this.y - cy;
                if (this.grounded && this.currentPlatform && this.currentPlatform.depressionOffset > 0) {
                    dy += this.currentPlatform.depressionOffset;
                }
                ctx.fillStyle = this.color; ctx.fillRect(this.x - cx, dy, this.w, this.h);
                ctx.fillStyle = '#000'; ctx.fillRect(this.x - cx + 15, dy + 15, 10, 10);
            }
            break(p) {
                this.opened = true; this.dead = true;
                if (Math.random() < 0.5) {
                    createParticles(this.x + this.w / 2, this.y + this.h / 2, '#ff4400', 15, 30);
                    camera.shake = 20; floatingTexts.push(new FloatingText(this.x, this.y - 20, "TRAP!", "#f00", 30));
                    if (Math.hypot((this.x + this.w / 2) - (p.x + p.w / 2), (this.y + this.h / 2) - (p.y + p.h / 2)) < 150) {
                        p.takeDamage(40); p.vx = (p.x < this.x ? -10 : 10); p.vy = -10;
                    }
                } else {
                    createParticles(this.x + this.w / 2, this.y + this.h / 2, '#ff0', 5, 10);
                    pickups.push(new HealthPickup(this.x, this.y));
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "LOOT!", "#ff0", 30));
                }
            }
        }
        class HealthPickup extends Entity {
            constructor(x, y) { super(x, y, 20, 20, '#0f0'); this.bob = 0; this.by = y; }
            update(p) {
                this.bob += 0.1; this.y = this.by + Math.sin(this.bob) * 5;
                if (checkRectCollide(this, p)) {
                    p.hp = Math.min(p.hp + 30, p.maxHp); this.dead = true;
                    floatingTexts.push(new FloatingText(this.x, this.y - 20, "+30 HP", "#0f0", 24));
                    createParticles(this.x + 10, this.y + 10, '#0f0', 5, 10);
                }
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                let dy = this.y - cy;
                if (this.grounded && this.currentPlatform && this.currentPlatform.depressionOffset > 0) {
                    dy += this.currentPlatform.depressionOffset;
                }
                ctx.fillStyle = this.color; ctx.fillRect(this.x - cx, dy, this.w, this.h);
                ctx.fillStyle = '#fff'; ctx.fillRect(this.x - cx + 8, dy + 4, 4, 12); ctx.fillRect(this.x - cx + 4, dy + 8, 12, 4);
            }
        }
        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 60, 100, CONFIG.colors.player);
                this.jumpCount = 0; this.dashCooldown = 0; this.isDashing = false; this.dashTimer = 0;
                this.attackCooldown = 0; this.attackHitbox = null; this.trail = [];
                this.spriteScale = 2.2; this.isAttackingAnim = false; this.attackFrame = 0;
                this.comboCount = 0; this.comboWindow = 0; this.prevGrounded = false;
                this.isLanding = false; this.landingTimer = 0; this.animSpeed = 0.25;
                this.isDying = false; this.deathTimer = 0; this.isSpawning = true; this.spawnTimer = 0;
                this.moveSpeedBonus = 1.0; this.attackSpeedBonus = 1.0;
                this.skillCooldown = 0; this.skillMaxCooldown = 1800;
                this.isSkillAnim = false; this.skillFrame = 0; this.isPlunging = false; this.invulnerableTimer = 0;
                this.energy = 0; this.maxEnergy = 100; this.isFrenzy = false; this.frenzyTimer = 0;
            }
            addEnergy(amount) {
                if (this.isFrenzy) return; 
                this.energy += amount;
                if (this.energy >= this.maxEnergy) {
                    this.energy = this.maxEnergy;
                    this.activateFrenzy();
                }
                document.getElementById('energy-fill').style.width = `${(this.energy/this.maxEnergy)*100}%`;
            }
            activateFrenzy() {
                this.isFrenzy = true;
                this.frenzyTimer = 600; 
                this.energy = 0;
                camera.shake = 20;
                floatingTexts.push(new FloatingText(this.x, this.y - 100, "FRENZY MODE!", "#d0f", 40));
                document.getElementById('energy-text').style.display = 'block';
                document.getElementById('frenzy-overlay').style.opacity = 1;
                this.hp = Math.min(this.hp + this.maxHp * 0.3, this.maxHp);
            }
            upgrade(t) {
                if (t === 'attack') { this.attackSpeedBonus += 0.1; floatingTexts.push(new FloatingText(this.x, this.y - 50, "ATK UP!", "#0f0", 30)); }
                else { this.moveSpeedBonus += 0.05; floatingTexts.push(new FloatingText(this.x, this.y - 50, "SPD UP!", "#0f0", 30)); }
                updateStatusPanel();
            }
            castSkill(enemies) {
                if (this.skillCooldown > 0) return;
                this.skillCooldown = this.skillMaxCooldown; camera.shake = 15;
                this.isSkillAnim = true; this.skillFrame = 0; this.state = 'skill'; this.vx = 0;
                createParticles(this.x, this.y, '#0ff', 20, 100);
                enemies.forEach(e => { if (!e.dead && Math.abs((e.x + e.w / 2) - (this.x + this.w / 2)) < 300) { e.freeze(300); } });
                floatingTexts.push(new FloatingText(this.x, this.y - 80, "FREEZE!", "#0ff", 30));
            }
            update(platforms, enemies) {
                if (this.dead) return;
                if (this.skillCooldown > 0) this.skillCooldown--;
                if (this.invulnerableTimer > 0) this.invulnerableTimer--;
                
                if (this.isFrenzy) {
                    this.frenzyTimer--;
                    if (this.frenzyTimer <= 0) {
                        this.isFrenzy = false;
                        document.getElementById('energy-text').style.display = 'none';
                        document.getElementById('frenzy-overlay').style.opacity = 0;
                    }
                    document.getElementById('energy-fill').style.width = `${(this.frenzyTimer/600)*100}%`;
                }

                if (this.isDying) {
                    this.vx = 0; this.vy = -1.5; this.x += this.vx; this.y += this.vy;
                    this.deathTimer++;
                    if (this.deathTimer > 100) { this.dead = true; setGameOver(); }
                    document.getElementById('health-fill').style.width = '0%';
                    return;
                }
                if (this.isSpawning) {
                    this.spawnTimer++; this.vx = 0; this.vy = 12; this.x += this.vx; this.y += this.vy;
                    for (let p of platforms) if (checkRectCollide(this, p)) {
                        this.y = p.y - this.h; this.isSpawning = false; this.grounded = true;
                        createParticles(this.x + this.w / 2, this.y + this.h, '#0ff', 20, 50); camera.shake = 15;
                    }
                    return;
                }
                this.prevGrounded = this.grounded;
                if (this.grounded) { this.jumpCount = 0; if (this.dashCooldown > 0) this.dashCooldown--; }
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.comboWindow > 0) this.comboWindow--;
                super.update(platforms); 
                if (!this.prevGrounded && this.grounded) {
                    this.isLanding = true; this.landingTimer = 0; createParticles(this.x + this.w / 2, this.y + this.h, '#fff', 2, 4);
                    if (this.isPlunging) { this.isPlunging = false; this.isLanding = false; this.performPlungeImpact(enemies, platforms); }
                }
                if (keys.left || keys.right || keys.jump || keys.dash || keys.attack) this.isLanding = false;
                if (!this.isDashing && !this.isSkillAnim && !this.isPlunging) {
                    let s = CONFIG.playerSpeed * this.moveSpeedBonus;
                    if (this.isFrenzy) s *= 1.5; 
                    if (keys.left) { this.vx -= 1.5; if (this.vx < -s) this.vx = -s; this.facingRight = false; }
                    if (keys.right) { this.vx += 1.5; if (this.vx > s) this.vx = s; this.facingRight = true; }
                }
                if (keys.jump && !this.isSkillAnim && !this.isPlunging) {
                    if (this.isDashing) { this.isDashing = false; this.vx *= 0.5; }
                    keys.jump = false;
                    if (this.grounded || this.jumpCount < 2) {
                        this.vy = -CONFIG.jumpForce; this.jumpCount++;
                        let c = this.jumpCount > 1 ? '#0ff' : '#fff'; createParticles(this.x + this.w / 2, this.y + this.h, c, 2, 8); this.isLanding = false;
                    }
                }
                if (!this.grounded && keys.down && keys.attack && !this.isPlunging) {
                    keys.attack = false; this.isPlunging = true; this.vy = 25; this.vx = 0; this.isDashing = false;
                }
                if (this.isPlunging) {
                    if (!this.grounded) { this.vy = 25; this.trail.push({ x: this.x, y: this.y, alpha: 0.4 }); }
                    else this.isPlunging = false;
                }
                if (keys.dash && this.dashCooldown <= 0 && !this.isDashing && !this.isSkillAnim && !this.isPlunging) {
                    keys.dash = false; this.isDashing = true; this.dashTimer = CONFIG.dashDuration; this.dashCooldown = 60;
                    if (this.isFrenzy) this.dashCooldown = 20; 
                    let d = this.facingRight ? 1 : -1; this.vx = d * CONFIG.dashSpeed; this.vy = 0; camera.shake = 8; this.comboCount = 0; this.isLanding = false;
                }
                if (this.isDashing) {
                    this.dashTimer--; this.vy = 0; this.x += this.vx;
                    for (let p of platforms) if (checkRectCollide(this, p)) { if (this.vx > 0) this.x = p.x - this.w; if (this.vx < 0) this.x = p.x + p.w; this.isDashing = false; this.vx = 0; }
                    this.trail.push({ x: this.x, y: this.y, alpha: 0.6 }); createParticles(this.x + this.w / 2, this.y + this.h / 2, '#0ff', 5, 3);
                    if (this.dashTimer <= 0) { this.isDashing = false; this.vx *= 0.2; }
                }
                if (keys.skill && !this.isSkillAnim) { keys.skill = false; this.castSkill(enemies); }
                if (keys.attack && this.attackCooldown <= 0 && !this.isSkillAnim && !this.isPlunging) {
                    keys.attack = false;
                    if (this.isAttackingAnim && this.comboWindow > 0) { this.comboCount++; if (this.comboCount > 3) this.comboCount = 1; } else this.comboCount = 1;
                    this.state = 'attack_' + this.comboCount;
                    let cfg = assets.hero[this.state]; let f = cfg ? cfg.frames : 4;
                    let spdMult = 1.0;
                    if (this.isFrenzy) spdMult = 2.0; 
                    this.animSpeed = ((f <= 4) ? 0.2 : 0.25) * this.attackSpeedBonus * spdMult;
                    let dur = f / this.animSpeed;
                    this.attackCooldown = dur - 5; this.comboWindow = dur + 20; this.isAttackingAnim = true; this.attackFrame = 0; this.isLanding = false;
                    this.performAttack(enemies);
                }
                if (this.isSkillAnim) {
                    this.state = 'skill'; this.skillFrame += 0.2; let mf = assets.hero.skill ? assets.hero.skill.frames : 3;
                    if (this.skillFrame >= mf) { this.isSkillAnim = false; this.state = 'idle'; }
                } else if (this.isAttackingAnim) {
                    this.attackFrame += this.animSpeed; let c = assets.hero[this.state]; let mf = c ? c.frames : 4;
                    if (this.attackFrame >= mf) { this.isAttackingAnim = false; this.state = 'idle'; }
                } else if (this.isDashing) this.state = 'dash';
                else if (this.isPlunging) this.state = 'plunge';
                else if (!this.grounded) this.state = 'jump';
                else if (this.isLanding) { this.state = 'jump'; this.landingTimer++; if (this.landingTimer > 12) { this.isLanding = false; this.state = 'idle'; } }
                else if (Math.abs(this.vx) > 0.5) this.state = 'run';
                else this.state = 'idle';
                document.getElementById('health-fill').style.width = `${(this.hp / this.maxHp) * 100}%`;
            }
            performPlungeImpact(enemies, platforms) {
                camera.shake = 20; impactEffects.push(new ImpactEffect(this.x + this.w / 2, this.y + this.h));
                let fx = this.x + this.w / 2; let fy = this.y + this.h + 2;
                for (let p of platforms) if (fx >= p.x && fx <= p.x + p.w && fy >= p.y && fy <= p.y + 20) { p.depressionOffset = 5; p.depressionTimer = 120; }
                let rx = this.x + this.w / 2; let ry = this.y + this.h;
                enemies.forEach(e => {
                    if (!e.dead) {
                        if (Math.hypot((e.x + e.w / 2) - rx, (e.y + e.h) - ry) < 200) {
                            e.takeDamage(50);
                            if (!e.frozen) { e.vy = -10; e.vx = (e.x < rx ? -10 : 10); }
                            createParticles(e.x + e.w / 2, e.y + e.h / 2, CONFIG.colors.enemy, 8, 10);
                            floatingTexts.push(new FloatingText(e.x, e.y - 40, "SMASH!", "#f0f", 30));
                        }
                    }
                });
            }
            takeDamage(a) {
                if (this.isDying || this.dead || this.invulnerableTimer > 0) return;
                this.hp -= a; this.invulnerableTimer = 60;
                floatingTexts.push(new FloatingText(this.x, this.y - 30, `-${Math.floor(a)}`, "#f00", 30));
                let r = a / this.maxHp; camera.shake = 10 + r * 20;
                let o = document.getElementById('damage-overlay'); o.style.opacity = Math.min(1, r + 0.3); setTimeout(() => o.style.opacity = 0, 200);
                if (r > 0.2) hitStop = Math.floor(r * 10) + 2;
                if (this.hp <= 0) {
                    this.hp = 0; this.isDying = true; this.vx = 0; this.vy = 0; this.dashTimer = 0; this.isDashing = false;
                    camera.shake = 30; hitStop = 10; createParticles(this.x + this.w / 2, this.y + this.h / 2, '#f00', 10, 50);
                }
            }
            performAttack(enemies) {
                // 修改：增加判定范围，让攻击距离更远 (120 -> 150)
                const r = 150; 
                const hX = this.facingRight ? this.x + this.w : this.x - r;
                this.attackHitbox = { x: hX, y: this.y, w: r, h: this.h, timer: 10 };
                
                // 新增：添加刀光特效
                // 在攻击动作开始时生成一个向前的刀光
                // 修改：增加 40px 的额外偏移，让刀光离角色更远
                const slashOffset = 40; 
                impactEffects.push(new SlashEffect(
                    this.x + (this.facingRight ? this.w + slashOffset : -slashOffset), 
                    this.y + this.h / 2, 
                    this.facingRight, 
                    this.isFrenzy
                ));

                let sa = 5; if (this.comboCount === 3) sa = 15; camera.shake = sa; this.vx = this.facingRight ? 5 : -5;
                for (let c of chests) if (!c.opened && checkRectCollide(this.attackHitbox, c)) c.break(this);
                for (let g of grenades) if (g.state === 'flying' && checkRectCollide(this.attackHitbox, g)) g.destroy();
                let hit = false;
                enemies.forEach(e => {
                    if (!e.dead && checkRectCollide(this.attackHitbox, e)) {
                        let d = 30, k = 10; if (this.comboCount === 3) { d = 60; k = 25; }
                        if (this.isFrenzy) d *= 2;
                        e.takeDamage(d);
                        if (!e.frozen) { e.vx = this.facingRight ? k : -k; e.vy = -5; }
                        createParticles(e.x + e.w / 2, e.y + e.h / 2, CONFIG.colors.enemy, 10, 15);
                        let tc = this.comboCount === 3 ? '#f00' : '#fff'; let ts = this.comboCount === 3 ? "CRIT!" : Math.floor(rand(25, 35));
                        floatingTexts.push(new FloatingText(e.x, e.y, ts, tc)); hit = true;
                    }
                });
                if (hit) camera.shake += 5;
            }
            draw(ctx, cx, cy) {
                if (this.dead) return;
                if (this.invulnerableTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;
                if (this.isDying) {
                    ctx.save(); let cx2 = this.x - cx + this.w / 2; let cy2 = this.y - cy + this.h / 2;
                    ctx.globalAlpha = 0.6 + Math.sin(this.deathTimer * 0.2) * 0.2; ctx.fillStyle = '#00ffff'; ctx.beginPath();
                    let r = 10 + this.deathTimer * 0.1; ctx.arc(cx2, cy2, r, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); let highlightOffset = r * 0.3; let highlightSize = r * 0.25;
                    ctx.arc(cx2 + highlightOffset, cy2 - highlightOffset, highlightSize, 0, Math.PI * 2); ctx.fill();
                    ctx.restore(); return;
                }
                if (this.isSpawning) {
                    ctx.save(); let cx2 = this.x - cx + this.w / 2; let cy2 = this.y - cy + this.h / 2;
                    for (let i = 1; i <= 15; i++) {
                        let oy = i * 5 + Math.random() * 5; let ox = (Math.random() - 0.5) * 20; let tr = Math.random() * 3 + 2; let a = 1 - (i / 15);
                        ctx.fillStyle = `rgba(0, 255, 255, ${a * 0.5})`; ctx.beginPath(); ctx.arc(cx2 + ox, cy2 - oy, tr, 0, Math.PI * 2); ctx.fill();
                    }
                    let cr = Math.min(5 + this.spawnTimer * 0.2, 30);
                    ctx.shadowBlur = 20; ctx.shadowColor = "#00ffff"; ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(cx2, cy2, cr, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.shadowBlur = 0; ctx.beginPath(); let highlightOffset = cr * 0.3; let highlightSize = cr * 0.25;
                    ctx.arc(cx2 + highlightOffset, cy2 - highlightOffset, highlightSize, 0, Math.PI * 2); ctx.fill();
                    ctx.restore(); return;
                }
                ctx.fillStyle = `rgba(0, 255, 255, 0.4)`; for (let t of this.trail) { t.alpha -= 0.1; if (t.alpha > 0) ctx.fillRect(t.x - cx, t.y - cy, this.w, this.h); }
                let dx = this.x - cx; let dy = this.y - cy;
                if (this.grounded && this.currentPlatform && this.currentPlatform.depressionOffset > 0) dy += this.currentPlatform.depressionOffset;
                let info = assets.hero[this.state] || assets.hero.idle;
                if (!info.img.complete || info.img.naturalWidth === 0) { ctx.fillStyle = this.isDashing ? '#ccffff' : this.color; ctx.fillRect(dx, dy, this.w, this.h); }
                else {
                    let f = 0;
                    if (this.state === 'jump') { if (this.isLanding) f = (this.landingTimer < 6) ? 2 : 3; else f = (this.vy < 0) ? 0 : 1; }
                    else if (this.state.startsWith('attack')) f = Math.floor(this.attackFrame);
                    else if (this.state === 'skill') f = Math.floor(this.skillFrame);
                    else if (this.state === 'plunge') f = 0;
                    else f = Math.floor(this.gameFrame / this.staggerFrames) % info.frames;
                    if (f >= info.frames) f = info.frames - 1;
                    ctx.save(); ctx.translate(dx + this.w / 2, dy + this.h / 2); if (!this.facingRight) ctx.scale(-1, 1);
                    
                    if (this.isFrenzy && this.gameFrame % 2 === 0) {
                        createParticles(this.x + this.w / 2, this.y + this.h / 2, '#aa00ff', 2, 3); 
                    }

                    let sw = info.img.width / info.frames; let dsz = sw * this.spriteScale;
                    let offY = (this.h / 2) - dsz;
                    ctx.drawImage(info.img, f * sw, 0, sw, info.img.height, -dsz / 2, offY, dsz, dsz); ctx.restore();
                }

                if (this.attackHitbox) {
                   this.attackHitbox.timer--;
                   if (this.attackHitbox.timer <= 0) this.attackHitbox = null;
               }
            }
        }

        function loop(ts) {
            if (gameState === 'GAMEOVER') {
                ctx.fillStyle = CONFIG.colors.bg; ctx.fillRect(0, 0, width, height);
                if (bgImage.complete && bgImage.naturalWidth !== 0) { let s = height / 600; let sw = 3472 * s; ctx.drawImage(bgImage, 0, 0, sw, height); } else { ctx.fillStyle = '#151525'; ctx.fillRect(0, 0, width, height); }
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, width, height);
                if (wanderingSoul) { wanderingSoul.update(); wanderingSoul.draw(ctx); }
                requestAnimationFrame(loop); return;
            }
            if (hitStop > 0) { hitStop--; requestAnimationFrame(loop); return; }
            requestAnimationFrame(loop);
            if (!lastFrameTime) lastFrameTime = ts; let el = ts - lastFrameTime;
            if (el > frameInterval) {
                lastFrameTime = ts - (el % frameInterval);
                if (player.x > 0) { distance = Math.floor(player.x / 100); dangerLevel = 1.0 + (distance / 100); }
                document.getElementById('dist-display').innerText = `DIST: ${distance}m`; document.getElementById('danger-display').innerText = `DANGER: ${dangerLevel.toFixed(1)}x`;
                let si = document.getElementById('skill-icon'); if (player.skillCooldown > 0) { si.classList.add('cooldown'); document.getElementById('skill-timer').innerText = Math.ceil(player.skillCooldown / 60); } else { si.classList.remove('cooldown'); document.getElementById('skill-timer').innerText = ''; }
                if (player.x + width > lastGeneratedX - 1000) extendLevel();
                let cl = player.x - 2000;
                platforms = platforms.filter(p => p.x + p.w > cl);
                enemies = enemies.filter(e => e.x > cl || (!e.dead && e.x > cl));
                chests = chests.filter(c => c.x > cl); pickups = pickups.filter(p => p.x > cl); grenades = grenades.filter(g => !g.dead);
                ctx.fillStyle = CONFIG.colors.bg; ctx.fillRect(0, 0, width, height);
                if (bgImage.complete && bgImage.naturalWidth !== 0) {
                    let s = height / 600; let sw = 3472 * s; let bx = -(camera.x * 0.5) % sw;
                    if (bx > 0) bx -= sw;
                    ctx.drawImage(bgImage, bx, 0, sw, height); ctx.drawImage(bgImage, bx + sw, 0, sw, height); if (bx + sw < width) ctx.drawImage(bgImage, bx + sw * 2, 0, sw, height);
                } else { ctx.fillStyle = '#151525'; for (let i = 0; i < 10; i++) ctx.fillRect((i * 600 - camera.x * 0.5) % 3000, 100, 200, height); }
                
                if (!player.isSpawning) {
                    let tx = player.x - width / 2 + player.w / 2; let lx = player.isDashing ? 0.2 : 0.1; camera.x += (tx - camera.x) * lx;
                    let dH = height * 0.3; let dT = height * 0.25; let psy = player.y - camera.y; let ty = camera.y;
                    if (psy < dT) ty = player.y - dT; else if (psy > dT + dH) ty = player.y - (dT + dH);
                    camera.y += (ty - camera.y) * 0.1;
                } else {
                    let tx = player.x - width / 2 + player.w / 2;
                    camera.x += (tx - camera.x) * 0.1;
                }
                
                let sx = 0, sy = 0; if (camera.shake > 0) { sx = (Math.random() - 0.5) * camera.shake; sy = (Math.random() - 0.5) * camera.shake; camera.shake *= 0.9; if (camera.shake < 0.5) camera.shake = 0; }
                const cdx = camera.x + sx; const cdy = camera.y + sy;
                if (groundPattern === null && groundImage.complete && groundImage.naturalWidth !== 0) groundPattern = ctx.createPattern(groundImage, 'repeat');
                platforms.forEach(p => {
                    if (p.x - cdx < width && p.x + p.w - cdx > 0) {
                        let py = p.y - cdy; if (p.depressionOffset > 0) py += p.depressionOffset;
                        if (groundPattern) { ctx.save(); ctx.fillStyle = groundPattern; ctx.translate(p.x - cdx, py); ctx.fillRect(0, 0, p.w, p.h); ctx.restore(); }
                        else { ctx.fillStyle = CONFIG.colors.platform; ctx.fillRect(p.x - cdx, py, p.w, p.h); }
                        ctx.fillStyle = CONFIG.colors.platformHighlight; ctx.fillRect(p.x - cdx, py, p.w, 6);
                    }
                });
                chests.forEach(c => c.draw(ctx, cdx, cdy));
                grenades.forEach(g => { g.update(platforms, player); g.draw(ctx, cdx, cdy); });
                for (let i = pickups.length - 1; i >= 0; i--) { let p = pickups[i]; p.update(player); p.draw(ctx, cdx, cdy); if (p.dead) pickups.splice(i, 1); }
                for (let i = impactEffects.length - 1; i >= 0; i--) { let e = impactEffects[i]; e.update(); e.draw(ctx, cdx, cdy); if (e.dead) impactEffects.splice(i, 1); }
                
                souls.forEach(s => s.update(player));
                souls = souls.filter(s => !s.dead);
                souls.forEach(s => s.draw(ctx, cdx, cdy));

                player.update(platforms, enemies); player.draw(ctx, cdx, cdy);
                enemies.forEach(e => { if (Math.abs(e.x - player.x) < width + 500) { e.update(platforms, player); } e.draw(ctx, cdx, cdy); });
                for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.update(); p.draw(ctx, cdx, cdy); if (p.life <= 0) particles.splice(i, 1); }
                for (let i = floatingTexts.length - 1; i >= 0; i--) { let t = floatingTexts[i]; t.update(); t.draw(ctx, cdx, cdy); if (t.life <= 0) floatingTexts.splice(i, 1); }
            }
        }

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        function startGame(){ gameState='PLAYING'; document.getElementById('start-screen').classList.add('hidden'); document.getElementById('game-over-screen').classList.add('hidden'); document.getElementById('skill-container').classList.remove('hidden'); initGame(); loop(); }
        function setGameOver(){ 
            gameState='GAMEOVER'; 
            document.getElementById('final-score').innerText=`DISTANCE: ${distance}m`; 
            document.getElementById('game-over-screen').classList.remove('hidden'); 
            document.getElementById('skill-container').classList.add('hidden'); 
            
            document.getElementById('frenzy-overlay').style.opacity = 0;
            document.getElementById('energy-text').style.display = 'none';
            document.getElementById('energy-fill').style.width = '0%';
            
            wanderingSoul=new WanderingSoul(width/2,height/2); 
        }
        function initGame(){ 
            score=0; killStreak=0; distance=0; dangerLevel=1.0; lastGeneratedX=-200; lastGeneratedY=height-100; 
            chests=[]; pickups=[]; grenades=[]; impactEffects=[]; souls=[]; 
            wanderingSoul=null; hitStop=0; 
            document.getElementById('cells-count').innerText="KILLS: 0"; updateStatusPanel(); 
            
            document.getElementById('frenzy-overlay').style.opacity = 0;
            document.getElementById('energy-text').style.display = 'none';
            document.getElementById('energy-fill').style.width = '0%';
            
            player=new Player(100,-200); platforms=[]; enemies=[]; particles=[]; floatingTexts=[]; platforms.push({x:-200,y:height-100,w:1200,h:1000,depressionOffset:0,depressionTimer:0}); lastGeneratedX=1000; extendLevel(); lastFrameTime=0; 
        }
        function updateStatusPanel(){ if(!player)return; const atk=Math.round(player.attackSpeedBonus*100); const spd=Math.round(player.moveSpeedBonus*100); document.getElementById('status-panel').innerHTML=`ATK SPEED: ${atk}%<br>MOV SPEED: ${spd}%`; }
        function extendLevel(){ 
            const gl=(player?player.x:0)+3000; 
            while(lastGeneratedX<gl){ 
                let sl=rand(400,900); 
                let dy=0; 
                if(Math.random()<0.7){dy=rand(180,350);if(Math.random()<0.5)dy=-dy;} 
                let ny=lastGeneratedY+dy; 
                const mn=200,mx=height-100; 
                if(ny<mn||ny>mx){ny=lastGeneratedY-dy;if(ny<mn||ny>mx)ny=lastGeneratedY;} 
                lastGeneratedY=ny; 
                if(Math.random()<0.2){let gs=rand(200,350);lastGeneratedX+=gs;} 
                platforms.push({x:lastGeneratedX,y:lastGeneratedY,w:sl,h:1000,depressionOffset:0,depressionTimer:0}); 
                if(Math.random()<0.05)chests.push(new Chest(lastGeneratedX+sl/2,lastGeneratedY-40)); 
                let cd=dangerLevel; let sc=Math.random(); let mc=0.2+(cd*0.05); 
                if(sc<mc)enemies.push(new MediumEnemy(lastGeneratedX+sl/2,lastGeneratedY-110,cd,cd)); 
                else if(sc<0.9)enemies.push(new Enemy(lastGeneratedX+sl/2+rand(-50,50),lastGeneratedY-70,cd,cd)); 
                
                if(Math.random()<0.5){let batY=lastGeneratedY-rand(280,400);enemies.push(new BatEnemy(lastGeneratedX+rand(100,sl-100),batY,cd,cd));} 
                
                if(Math.random()<0.5){let ph=lastGeneratedY-rand(150,250);let pw=rand(150,250);platforms.push({x:lastGeneratedX+rand(0,sl-pw),y:ph,w:pw,h:30,depressionOffset:0,depressionTimer:0});} 
                lastGeneratedX+=sl; 
            } 
        }
        function createParticles(x,y,c,s,c2){ for(let i=0;i<c2;i++)particles.push(new Particle(x,y,c,s,rand(4,10),rand(20,40))); }
        window.addEventListener('keydown', e => { if(gameState!=='PLAYING')return; switch(e.code){ case 'KeyA':case 'ArrowLeft':keys.left=true;break; case 'KeyD':case 'ArrowRight':keys.right=true;break; case 'KeyW':case 'ArrowUp':keys.up=true;break; case 'KeyS':case 'ArrowDown':keys.down=true;break; case 'Space':case 'KeyK':keys.jump=true;break; case 'KeyJ':keys.attack=true;break; case 'KeyE':keys.skill=true;break; case 'ShiftLeft':case 'KeyL':keys.dash=true;break; } });
        window.addEventListener('keyup', e => { switch(e.code){ case 'KeyA':case 'ArrowLeft':keys.left=false;break; case 'KeyD':case 'ArrowRight':keys.right=false;break; case 'KeyW':case 'ArrowUp':keys.up=false;break; case 'KeyS':case 'ArrowDown':keys.down=false;break; case 'Space':case 'KeyK':keys.jump=false;break; case 'KeyJ':keys.attack=false;break; case 'KeyE':keys.skill=false;break; case 'ShiftLeft':case 'KeyL':keys.dash=false;break; } });
        window.addEventListener('mousedown', () => { if(gameState==='PLAYING')keys.attack=true; });
        window.addEventListener('mouseup', () => { if(gameState==='PLAYING')keys.attack=false; });
        
        const setupTouch = (id, k) => { 
            const el = document.getElementById(id); 
            el.addEventListener('touchstart', e => { 
                e.preventDefault(); 
                keys[k] = true; 
            }, { passive: false }); 
            el.addEventListener('touchend', e => { 
                e.preventDefault(); 
                keys[k] = false; 
            }, { passive: false }); 
        };
        setupTouch('btn-left','left'); setupTouch('btn-right','right'); setupTouch('btn-jump','jump'); setupTouch('btn-attack','attack'); setupTouch('btn-dash','dash'); setupTouch('btn-skill','skill');
        setupTouch('btn-down', 'down');
    </script>
</body>
</html>